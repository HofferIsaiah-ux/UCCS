package cs1450;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

/* 
Isaiah Hoffer 
CS1450 (M/W)
5/1/25
Assignment 10

*/
public class HofferIsaiahAssignment10 {

	public static void main(String[] args) throws FileNotFoundException {
		
		//Creating BinaryTree
		BinaryTree parrotTree = new BinaryTree();

		//Creating And Scanning File
		File parrotFile = new File("parrots.txt");
		Scanner parrotRead = new Scanner(parrotFile);
		
		while(parrotRead.hasNext()) {
			
			int parrotID = parrotRead.nextInt(); //Gets ID Of Parrot
			String parrotName = parrotRead.next(); //Gets Name Of Parrot
			String parrotLyric = parrotRead.nextLine().trim(); //Gets Parrot Song Word
			
			//Creating And Insterting Parrot To Binary Tree
			parrotTree.insert(new Parrot(parrotID, parrotName, parrotLyric));
		}//While
		
		//Caling LevelOrder Method
		//Pretext
		System.out.printf("Parrot's Song\n"
				+ "-------------------------------------------\n");
		parrotTree.levelOrder();
		
		//Calling visitLeaves Method
		//Pretext
		System.out.printf("\n\nParrots On Leaf Nodes\n"
				+ "-------------------------------------------\n");
		parrotTree.visitLeaves();
		
	}//main
}//class

//Parrot Object To Hold Id, Name, And Song Lyric
class Parrot implements Comparable<Parrot> {
	
	//Private Data 
	private int id; //Holds Parrot ID
	private String name; //Holds Parrots Name
	private String songWord; //Hold Parrto's Lyric For Song 
	
	public Parrot(int id, String name, String songWord) {
		
		
		//Initalizing Data 
		this.id = id;
		this.name = name;
		this.songWord = songWord;
		
	}//Parrot Constructor
	
	//Getter To Return Name
	public String getName() {
		
		return name;
	}//GetName Method
	
	//Getter For SongWord
	public String sing() {
		
		return songWord;
	}//Sing Method
	
	@Override
	public int compareTo(Parrot otherParrot) {
		
		return this.id - otherParrot.id;
		
	}//compareTo Method
	
}//Parrot Class

class BinaryTree {
	
	//Private Data
	TreeNode root; //Head Of Tree
	
	public BinaryTree() {
		
		//Initalizing Private Data 
		this.root = null;
	}//BinaryTree Constructor 
	
	//Adds Parrot To Tree, Returns True Or False
	public boolean insert(Parrot parrotToAdd) {
		
		//Creating Node
		TreeNode treeNode = new TreeNode(parrotToAdd);
		
		//Boolean Variable
		Boolean didInsert = false;
		
		if(root == null) {
			root = treeNode;
		}//If
		
		else {
			
			TreeNode current = root;
			
			while(!didInsert) {
				
				if(parrotToAdd.compareTo(current.parrot) < 1) {
					
					if(current.left == null) {
						
						current.left = treeNode;
						didInsert = true;
					}//If
					else {
						current = current.left;
					}//Else
				}//If
				
				if(parrotToAdd.compareTo(current.parrot) >= 1) {
					
					if(current.right == null) {
						
						current.right = treeNode;
						didInsert = true;
					}//If
					else {
						current = current.right;
					}//Else
					
				}//If
			}//While
		}//Else
		
		return didInsert;
	}//Insert Method
	
	//Traverse Tree, Prints Parrot's Lyric
	public void levelOrder() {
		
		if(root != null) {
			
			//Creating Queue
			Queue<TreeNode> nodeQueue = new LinkedList<>();
			
			//Adding Root To Queue
			nodeQueue.offer(root);
			
			while(!nodeQueue.isEmpty()) {
				
				TreeNode current = nodeQueue.remove();
				System.out.printf("%s ",current.parrot.sing());
				
				//Adding Left Node
				if(current.left != null) {
					
					nodeQueue.offer(current.left);	
				}//If
				
				//Adding Right Node
				if(current.right != null) {
					
					nodeQueue.offer(current.right);
				}//If
				
			}//While	
		}//If
	}//levelOrder Method
	
	//Calls Private visitLeaves Class
	public void visitLeaves() {
		
		visitLeaves(this.root);
	}//visitLeaves Public Method
	
	
	private void visitLeaves(TreeNode aNode) {
				
		if(aNode != null) {
			
			visitLeaves(aNode.left);
			if(aNode.left == null && aNode.right == null) {
				System.out.println(aNode.parrot.getName());
			}
			visitLeaves(aNode.right);
			
		}
			
	}//visitLeaves Private Method
	
	private class TreeNode {
		
		//Private Data
		Parrot parrot; //Hold Parrot Object
		TreeNode left; //Pointer To Go Left Of Tree
		TreeNode right; //Pointer To Go Right Of Tree
		
		public TreeNode(Parrot parrot) {
			
			//Initalizing Private Data
			this.parrot = parrot;
			this.left = null;
			this.right = null;
		}//TreeNode Constructor 
		
	}//TreeNode Private Class
	
}//BinaryTree Class

